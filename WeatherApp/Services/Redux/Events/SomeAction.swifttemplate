import Foundation

<%
func camelCased(_ string: String) -> String {
  return "\(String(string.first!).lowercased())\(String(string.dropFirst()))".replacingOccurrences(of: ".", with: "")
}

func allActions() -> [Type] {
  return types.all.filter { type in
    (type is Struct || type is Enum) && (type.implements["Action"] != nil)
  }
}
-%>

enum SomeAction: Codable {
<%_ for type in allActions() { -%>
  case <%= camelCased(type.name) %>(<%= type.name %>)
<%_ } -%>

  init(_ action: Action) {
    switch action {
    <%_ for type in allActions() { -%>
    case let action as <%= type.name %>: self = .<%= camelCased(type.name) %>(action)
    <%_ } -%>
    default: fatalError("Unexpected action")
    }
  }

  var action: Action {
    switch self {
    <%_ for type in allActions() { -%>
    case let .<%= camelCased(type.name) %>(action): return action
    <%_ } -%>
    }
  }

  enum Keys: CodingKey {
    case type, action
  }

  enum ActionType: String, Codable {
  <%_ for type in allActions() { -%>
    case <%= camelCased(type.name) %>
  <%_ } -%>
  }

  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: Keys.self)
    let type = try container.decode(ActionType.self, forKey: .type)
    switch type {
    <%_ for type in allActions() { -%>
    case .<%= camelCased(type.name) %>: self = .<%= camelCased(type.name) %>(try container.decode(<%= type.name %>.self, forKey: .action))
    <%_ } -%>
    }
  }

  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: Keys.self)
    switch self {
    <%_ for type in allActions() { -%>
    case .<%= camelCased(type.name) %>(let action):
      try container.encode(ActionType.<%= camelCased(type.name) %>, forKey: .type)
      try container.encode(action, forKey: .action)
    <%_ } -%>
    }
  }
}
